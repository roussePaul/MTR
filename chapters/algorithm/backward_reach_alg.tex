\section*{Notation}
\begin{tabular}{ll}
FTS:& Finite Transition System\\
LTL:& Linear Temporal Logic\\
BA: & B\"uchi Automaton\\
DBA:& Deterministic B\"uchi Automaton\\
NBA:& Nondeterministic B\"uchi Automaton\\
BFS:& Breadth First Search\\
DFS:& Depth First Search\\
\end{tabular}

For $X,Y$ two sets, $X|_Y = \{x \in X \mid x \notin  Y \}$, $2^X$ is the power set of $X$.

Let a graph $G = (V,E)$.
For a node $x \in V$, $Post(x)$ and $Pre(x)$ correspond respectively to the set of successors and predecessors of $x$. 
For a set of nodes, we define $X \subseteq V$, $Post(X) = \bigcup_{x \in X} Post(x)$, $\outpost(X) = Post(X) \setminus X$, $Pre(X) = \bigcup_{x \in X} Pre(x)$ and $\inpre(X) = Pre(X) \setminus X$.

For $X_1,\dots,X_n$ n sets and $Y \subset X_1 \times \dots \times X_n$, lets define the projection of $Y$ on $X_i$ with $Y|_{X_i} = \{x_i \mid (x_1,\dots,x_n) \in Y\}$.
The powerset of $X$ will be denoted $2^X$.
$\leftint a,b \rightint$ denote the segment of $\mathbb{N}$ between $a$ and $b$.

For a finite set $X$, and $Y \subseteq 2^X$, we define $\tilde{Y} = \bigcup_{y\in Y} y \subseteq X$.

\section{Introduction}
\newcommand{\Aphi}{\mathcal{A}_\varphi}%
\newcommand{\Fts}{\mathcal{F}}%
When the discretization of the state space and of the input space is finite the previously computed abstraction result in a Finite Transition System (FTS) $\Fts$. This FTS is meant to be used with the Linear Temporal Logic (LTL) specifications in order to synthesize a controller. This chapter details the controller synthesis algorithm.

As the final FTS is usually non deterministic, we have been using a slightly modified backward reachability algorithm that is using the maximal time of travel of the agent in order to prove the actual LTL fairness.

LTL formula can associate to an infinite sequence of observations a truth or a false value. These formulas have first been introduced in computer science fields for verifications purposes and yet attract interest of the control community to express high level specifications easily.
The power of such a language rely in its expressiveness and the ability to translate these formulas into a formal mathematical object that is easily manipulable: the \buchi{} Automaton.

LTL formulas can be translated in a \buchi{} Automaton that have a finite number of transition bringing graph theory into the field of verification.
Any sequence of observation that is part of the language of an LTL formula $\varphi$ will verify a so called acceptance condition of the corresponding \buchi{} Automaton $\Aphi$.
Adding the previously found abstraction, the system and its specifications are now expressible within the same class of object: finite state machines.
One can compose them into a \textit{Product Automaton} that encapsulate both the behaviour of the system and the formula specifications into a single automaton.
Every path verifying the acceptance condition in the Product Automaton respect both transitions in $\Fts$ (ie the dynamic of the system) and the acceptance condition $\Aphi$ (ie the formula $\varphi$).

The finiteness of the Product Automaton allow us to us graph search algorithm to generate controllers that force the system to verify the LTL formula.

In our case, the $\Fts$ is not deterministic and might have self-loops, this brought some more challenges in order to generate the controller out of it.
In this chapter, we will first introduce the necessary definitions, then detail the product of $\Fts$ and $\Aphi$, and finish with the description of the a slightly modified backward reachability algorithm that can work with deterministic FTS.

\subsection{Related work}
In linear temporal logic, the accepting set must be reached in finite time (fairness property). For a deterministic finite transition systems, the solutions already verify this property: a solution is done in a finite sequence of state/transition, so in finite time as well.
For non deterministic planning problems, this property is not granted. A solution plan with a cycle outside of the goal set will have trajectories that loops infinitely.

% Strong cyclic planning
Assuming that all transitions of a cycle will be taken in an infinite run (fairness property) can partially solve the issue.
Strong cyclic algorithms find plans with cycles, the global fairness property ensure that the solution will reach the goal set in finite time.
However, if this hypothesis can be justified in action planning and in verification in computer science, this assumption cannot be done in controller synthesis.
A wrong control combination can lead to limit cycles or equilibrium that might not be escaped.

The solution the that we brought is a strong cyclic algorithm with local fairness property. This means the assumption of fairness is not a global assumption any more and needs to be computed according to the cells shape of the state space discretization and to the control combinations
This part is presenting the planning under strong fairness constraint.

I will first present a graph decomposition. This decomposition will be used to show that any plans of a non deterministic with local fairness property problem can be decomposed in a graph of strongly connected cyclic modules. If each of the modules are fair, all the runs will reached the goal set in finite time.
This decomposition will be then used to create an algorithm that search for these solutions.

%Lets consider a product automaton $\Pi_\varphi$ between a finite transition system $\mathcal{F}$ and a nondeterministic b\"uchi automaton $\mathcal{A}_\varphi$ obtained from a LTL property $\varphi$. Lets call $\widetilde{\Pi}_\varphi$ the finite transition system that have the same nodes, initial states and transitions than $\Pi_\varphi$.
%
%In the case that $\Pi_\varphi$ have cycles that does not contain any accepting nodes, it can happen that a run is in $\widetilde{\Pi}_\varphi$ but not in $\Pi_\varphi$.
%This happen when the cycle "block" the system (the state will never escape the cycle). In order to suppress this behaviour, we have to detect which control sequence can block the system.

\comment{
\cite{de2010generalized}
\cite{patrizi2013fair}
By modelling the system in this way we are losing a lot of expressiveness power of the LTL. However, the complexity remain more or less the same than before 2EXPTIME-complete ($\mathcal{O}(2^{2^{n^k}})$) (\textit{not so sure about it, double check information}).
}

Non determinism model with LTL planning has been investigated mostly in the sensing non determinism or environment uncertainty.
Many solutions in $\mu$-calculus formulation (generalized reactivity) has been investigated. However they perform well in an environment with low non determinism (the complexity of the problem does not make it suitable for a motion planning problem).
ho alt
As temporal logic is mostly used for high level control specifications, usually only the low level controller has to deal with the noise.
That is why most of the motion planning problems with LTL specifications  assume that the motion of the robot is deterministic.
Another reason lie in the state space explosion problem: relatively simple planning problems can result in an unrealistic needs of computing resources.

Some attempts using Markov decision process bring good results at reducing the complexity and using LTL specifications on real robots. These models can then provide a success probability of the LTL formula. 

In the motion planning community, the Fully Observed Non Deterministic problem  

In a planning problem, a solution plan cannot have cycles that does not contain any goal nodes, otherwise the agent might loop infinitely on the same cycle without meeting the goal set. If the system is verify fairness property, then any plan even with cycles will solve the problem. Otherwise the planner have to avoid any cycles.
In its simplest form, non deterministic cycles appear in system that contain self-loops. If the non determinism for the rest of the system is acquired, then by using a fragment of LTL formulas (without the next operator), a regular deterministic planning algorithm can solve the problem.

\comment{For motion planning, the fairness property is verified for a set of nodes if the agent leave the set of nodes in a finite time.
In our case, the fairness property is not always met: a "wrong" combination of controls can create an equilibrium point or a limit cycle.
Therefore checking the truth value of this property cannot be done globally but for each cycles of the plan that does not contain the goal set.
As the number of cycles and control combination is high, checking the fairness property is not possible in practice. This will be done online.}


\comment{Talk about why they have been doing this? Deal with uncertainty about the environment.
Why did you chose LTL?
Why did you chose B\"uchi Automaton?
Talk about other solutions that might have been smarter.}


%\cite{de2010generalized}
%\cite{patrizi2013fair}
%Fully Observable Non-Deterministic Planning:  FOND
%
%The guaranties that an nondeterministic planner must fulfil are:
%\begin{itemize}[noitemsep,nolistsep]
%\item \textbf{Completness.}
%\item \textbf{Soundness.} Every given solutions are correct
%\item \textbf{Correctness.} 
%\item \textbf{Fairness.}
%\end{itemize}
%
%\subsection{Related work}
%How to deal with nondeterminism?
%Different approaches:
%\begin{itemize}
%\item general game formulation: GR(1) (however, the formulation does not fit to our needs): in \cite{de2010generalized} and \cite{Kissmann2009}, the strong fairness property is expressed thanks in a LTL formulation, however it presuppose a knowledge about cyclic actions fairness property, this is adapted to action planning where we know that if the action is infinitely repeated, then the action will success infinitely often. This does not really fit any motion planning non determinism where the fairness property depend on a control configuration over the cells. Using this kind of framework will force us to go through all the possible action combinations and determine which one is fair.
%\item Fixed point ($\mu$-calculus that is related to the GR formulation as well).
%\item \cite{fu2011simple} is solving the FOND problem in the case of strong fairness assumption. This assumption is global, this is not the case for us as some of some control configurations might be unfair. The fairness property is local in our case.
%\end{itemize}
%
%What I did is an adaptation of the \cite{fu2011simple} with a backward reachability algorithm.

\section{Preliminaries}
\subsection{Linear Temporal Logic}
\newcommand{\AP}{\mathrm{AP}}
LTL is a specification language first introduced in \cite{pnueli1977temporal}. Since then it has been widely used in robot motion and action planning mainly for its expressiveness and mathematical equivalent representation in \buchi{} Automaton.
LTL property are defined inductively with :
\begin{equation}
\varphi ::= 
\true \mid 
a \mid 
\varphi_1 \land \varphi_1 \mid
\lnot \varphi \mid
\LTLnext \varphi \mid
\varphi_1 \LTLuntil \varphi_2
\end{equation}
where $\true$ is the symbol defined by $\true = a\lor \lnot a$, $a \in \AP$ is a predicate (that will depend on the state on the robot), $\AP$ a set of predicates, $\varphi_1$ and $\varphi_2$ are LTL formulas, $\lnot$ is the not operator defined by $a = \lnot \lnot a$, $\LTLnext$ is the next operator and $\LTLuntil$ is the until operator.
The truth of an LTL formula is defined in this way:
\begin{nameddef}{LTL property}
The sequence of observation $\sigma = S_0 S_1 S_2 ...$, with $S_k \in 2^{\AP}$ a set of observed labels for $k=0,1,2,...$, satisfy the LTL formula $\varphi$ iff $(\sigma,0) \vDash \varphi$ where $\vDash$ is defined recursively by: 

\begin{tabular}[b]{rcl}
$(\sigma,k) \vDash a$ & $\leftrightarrow$ & $a \in S_k$\\
$(\sigma,k) \vDash \lnot \varphi$ & $\leftrightarrow$ &  $(\sigma,k) \nvDash  \varphi$ \\
$(\sigma,k) \vDash \LTLnext \varphi$ & $\leftrightarrow$ &  $(\sigma,k+1) \vDash  \varphi$ \\
$(\sigma,k) \vDash \varphi_1 \lor \varphi_2$ & $\leftrightarrow$ &  $(\sigma,k) \vDash  \varphi_1$ or $(\sigma,k) \vDash  \varphi_2$ \\
$(\sigma,k) \vDash \varphi_1 \LTLuntil \varphi_2$ & $\leftrightarrow$ &  $\exists k' \in \left [k, +\infty \right ] , (\sigma,k') \vDash \varphi_2$ and \\
& & $\forall k'' \in (k,k'), (\sigma,k'') \vDash \varphi_1$ \\
\end{tabular}
\end{nameddef}

We also define some useful operators: \textit{eventually} $\LTLeventually \varphi = \true \LTLuntil \varphi$, \textit{always} $\LTLalways \varphi = \lnot \LTLeventually \lnot \varphi$, \textit{implication} $\varphi_1 \LTLimply \varphi_2 = \lnot \varphi_1 \lor \varphi_2$.
More details can be found in chapter 5 of \cite{principlemodelchecking}.

All the power of such a language lie in the ability to transform a human writeable formula in a machine manipulable data. LTL formula can be translated to an automaton structure that can be easily manipulated with discrete models. The problem of path planning is then reduced to finding a path in graph.

\subsection{Automaton}
Every LTL formula can be translated in a Nondeterministic \buchi{} Automaton:
\begin{nameddef}{Nondeterministic B\"{u}chi Automaton}
$\mathcal{A}_{\varphi} = (Q, Q_0, 2^{AP}, \delta, \mathcal{Q})$
where:
\begin{itemize}[noitemsep,nolistsep,topsep=0pt,after=\relax]
\item $Q$ finite set of states;
\item $Q_0 \subseteq Q$ a set of initial states;
\item $2^{AP}$ the alphabet;
\item $\delta: Q \times 2^{AP} \times Q$ a transition relation ;
\item $\mathcal{Q}$ set of accepting states.\popQED
\end{itemize}
\end{nameddef}
It should be noted that a trace with elements in $2^{AP}$ verify the LTL formula if there is corresponding sequence of states of the NBA that infinitely goes to the accepted set $\mathcal{Q}$.

Nota: if $\forall q \in Q, \forall a \in 2^{AP}, | \delta(a,q) | \leq 1$, then $\mathcal{A}_{\varphi} = (Q, Q_0, 2^{AP}, \delta, \mathcal{Q})$ is a \textit{Deterministic B\"uchi Automaton} (DBA).

The FTS will be defined as a system (see defintion \label{def:system}) with a finite set of transition (in practice this imply that the set of states is finite as well). Also the same notation as in defintion \label{def:system} will be used.

When it comes to multi-agent control, 2 methods can give us the FTS, either the dynamical models are concatenated and then the FTS is computed using abstraction methods. Either the 2 FTS are computed separately and the final FTS is then obtained by computing the product of the 2 FTS:
\begin{nameddef}{Product of 2 FTS}
The product automaton $\mathcal{F}_p$ of 2 non deterministic FTS $\mathcal{F}_1$ and $\mathcal{F}_2$ is defined by
$\mathcal{F}_p = \mathcal{F}_1 \otimes \mathcal{F}_2
= (X',X_0',U',\delta',Y',H')$
where
$X' = X_1 \times X_2$ is the set of states,
$X_0' = X_{10} \times X_{20}$ is the set of initial states,
$U' = U_1 \times U_2$ the input set,
$Y' = Y_1 \times Y_2$ the output set,
$H': X_1,X_2 \rightarrow (H_1(X_1),H_2(X_2))$ the output map,
$\delta' \subseteq X' \times U \times X'$
is the transition relation defined by
$\left \langle x_1,x_2 \right \rangle \in \delta'(\left \langle x_1',x_2' \right \rangle,\langle u_1,u_2 \rangle)$ iff $x_1 \systransition{\mathcal{F}_1}{u_1} x_1'$ and $x_2 \systransition{\mathcal{F}_2}{u_2} x_2'$.
\end{nameddef}
This is a synchronous product as every transition of the product correspond to a transition in each of the models.

\newcommand{\Aprod}{\mathcal{A}_p}
We would like to force the system to verify an LTL formula. We will assume that the observation function of the FTS is in the following form: $H:X \rightarrow 2^{AP}$ and $Y = 2^{AP}$.
The product automaton for an nondeterministic FTS is defined as follow:
\begin{nameddef}{Product of a NBA and a FTS}
The product automaton $\Aprod$ of the NBA $\Aphi$ and the non deterministic FTS $\mathcal{F}_c$ is defined by
$\Aprod = \mathcal{F}_c \otimes \Aphi
= (Q',Q_0',\delta',\mathcal{Q}')$
where
$Q' = X \times Q$ is the set of states,
$Q_0' = X_0 \times Q_0$ is the set of initial states,
$\mathcal{Q}' = X \times \mathcal{Q}$ the acceptance set,
$\delta' \subseteq Q' \times U \times Q'$
is the transition relation defined by
$\left \langle x',q' \right \rangle \in \delta'(\left \langle x,q \right \rangle ,u)$
iff $x' \in Post_u(x)$, $q' \in \delta(q,H(x'))$ and 
$\forall y \in Post_u(x), \delta(q,H(y)) \neq \emptyset$.
\end{nameddef}
Roughly speaking, a $u$-transition in the product automaton is valid iff for every possible next observation of a $u$-transition in the FTS, it exists a valid transition in the B\"uchi Automaton.

Every path in the product automaton that infinitely goes to the acceptance set verifies the LTL formula $\varphi$ and takes only valid transitions of the FTS (so it respect the model of the system).
So now, if we find a plan that force the product automaton to go infinitely often to the accepted set, then the controlled system will verify the LTL formula.
It is important to note that the acceptance set must be reached in a finite time otherwise the LTL formula is not verified.

\subsection{Fix point algorithm}
%% introduce the fixed point property, make a link between mu calculus
%% I just need a property that establish the working conditions for the fixed point property and the finitness of the algorithm.

% definition of a fixed point
% definition of the least fixed point
% definition of a monotonic fonction t: 2^S -> 2^S
% theorem tarski-knaster for the fixed point of a monotonic function -> existence of the least fixed point
% include the finitness directely inside the theorem, or as a note
In the next parts, we will use operations over sets of nodes in the graph. In order to find subset of nodes where properties are verified, we will use fixed point computation.

Let the graph $(S,E)$, a functional $\tau$ is a function over powersets of $S$: $\tau: 2^S \rightarrow 2^S$. We say that $b$ is a \inlinedef{fixed point} of the functional $\tau$ if $\tau(b) = b$.
The functional $\tau: 2^S \rightarrow 2^S$ is  \inlinedef{monotonic} iff $\forall a,b \in 2^S, a \subseteq b, \tau(a) \subseteq \tau(b)$.
In \cite{tarski}, it is shown that for a monotonic functional $\tau$, the set of fixed points has a least and greatest element denoted by $\mu \tau$ and $\nu \tau$ respectively:
\begin{namedtheo}{Tarski-Knaster}\label{th:tarski}
Let $\tau:2^S \rightarrow 2^S$ a monotonic functional:
\begin{itemize}[noitemsep,nolistsep]
\item $\mu \tau = \bigcap \{b \subseteq S \mid \tau(b) \subseteq b\} = \bigcup_{\alpha \in On} \tau^{\alpha}(\emptyset)$
\item $\nu \tau = \bigcup \{b \subseteq S \mid b \subseteq \tau(b) \} = \bigcap_{\alpha \in On} \tau^{\alpha}(S)$
\end{itemize}
where $\tau^{\alpha}$ is the $\alpha^{th}$ composition of $\tau$ and $On$ the class of ordinals.
\end{namedtheo}
In our case, $S$ will be a finite set and $On = \leftint 1,|S|\rightint$. 
Therefore the theorem ensure the existence and the finiteness of the least fixed point computation.
Please note that if $a$ and $b$ are least fixed points of the monotonic functional $\tau$, then $a \subseteq b$ and $b \subseteq a$, which means that $a=b$, which means that the least fixed point is unique.

\section{Decomposition in strongly connected cyclic components}
\newcommand{\planningdomain}{\ensuremath{ \tuple{\langle S, S_0, \mathcal{A}, \gamma \rangle} }}%
%
\newcommand{\controller}{\ensuremath{\tuple{ \langle C, c_0, \Gamma, \Lambda, \delta, \Omega \rangle}}}%
%
\newcommand{\planningproblem}{\ensuremath{\tuple{ \langle \mathcal{D}, G \rangle}}}%
\newcommand{\Fsc}{\Pi}%
\newcommand{\Ftcs}{\Fts_\Fsc}%
\newcommand{\Asol}{\mathcal{A}_s}%
%
Hereby we will introduce some definitions that will be used for the planning problem.
In order to solve the planning problem, we will introduce the Finite-State Controller (FSC):
\begin{nameddef}{Finite-State Controller}
$\Fsc = \controller$ is a finite-state controller where
$C$ is the set of states,
$c_0$ is the initial state,
$\Gamma$ is the controller input alphabet,
$\Lambda$ is the output alphabet,
$\delta: C \times \Gamma \rightarrow C$ is the transition function and 
$\Omega: C \rightarrow \Lambda$ is the output function.
\end{nameddef}
In practice, for a product automaton $\Aprod = \systuple{Q',Q'_0,\delta', U,Y,\mathcal{Q}'}$, the controller $\Fsc = \controller$ will be chosen with $C = Q' \cup \{c_0\}$, $\Lambda = U$ and $\Gamma = Y$.
$\Fsc$ is said to be \textit{closed} if every reachable state of $\Aprod$ is associated with a control action.
If $\Fsc$ is closed, this controller could be composed with the FTS $\Fts$: $\Ftcs = \Fts \circ \Fsc = \systuple{X_\Fsc,X_{\Fsc 0},\systransition{\Ftcs}{},\{u\},Y,H}$.
The input set of the composed system is a singleton, this is just a dumb input introduced mainly for compatibility with the rest of the definitions.
Finally we can obtain the product of the composed system:
$\Asol = \Aphi \otimes \Ftcs = \systuple{S,S_0,\delta,G}$.
Due to the special form of the controller, $\Asol$ correspond to the product automaton $\Aprod$ selecting just one of the input.
$\Fsc$ is \textit{proper} if the acceptance set of $\Asol$ is reachable from every initial state and $\Fsc$ is said \textit{fair} if the acceptance set is reachable in finite time from every nodes of $\Asol$.
We will say that $\Fsc$ is a valid controller if $\Fsc$ is \textit{closed}, \textit{proper} and \textit{fair}.

This is a non terminating problem as all trajectories will have to go infinitely to the goal set.
It is shown in \cite{patrizi2013fair} that every non-terminating nondeterministic planning problem can be solved like a nondeterministic terminating planning problem where the the initial set of correspond to the union of the initial set and the goal set.
Lets call $\Asol' = \systuple{S \cup G_0,S_0 \cup G_0,\delta',G}$ the solution of the nondeterministic terminating problem, where $G_0$ is a set of nodes that have the same transition relations than $G$ but does not belong to the goal set.

In this next sections we will proof that every solutions can be decomposed in strong cyclic components.
Then we will investigate the consequences of the fairness property over the set of solution.
Finally, we will use all these properties in order to justify the planning algorithm that we used.

\subsubsection{Strong cycle decomposition}
In this section we will use a constructive argument to show that every plan of a terminating nondeterministic planning problem can be decomposed in strong cyclic components that deterministically go to the goal set.

Let a $\Asol$ a solution of the planning problem.
The main idea of the decomposition is to decompose $\Asol$ in strong cyclic components that deterministically bring us to the goal set of nodes.
To do this we will recursively find all the smallest strongly connected cycles that deterministically bring the state closer to the goal set (closer in term of node distance).
The description of the construction will be followed by a proof that for a valid plan  all the nodes of the plan belong to the decomposition.

Strongly connected components will be found using fixed point algorithm.
Let $F_{t \rightarrow g}$ defined for $g,t \subseteq S$ by:
\begin{equation}
\begin{array}{llll}
F_{t \rightarrow g} :& 2^S & \rightarrow & 2^S\\
 & x &  & (Post(x) \cap S \setminus_g) \cup t
\end{array}
\end{equation}


For $x \subseteq y$ we have $F_{t \rightarrow g} (x) \subseteq F_{t \rightarrow g}(y)$, so $F_{t \rightarrow g}$ is a monotonic functional and theorem \ref{th:tarski} ensure that $F_{t \rightarrow g}$ have a unique least fixed point.
As the cardinality of $S$ is finite, we can compute the fixed point of $F_{t \rightarrow g}$ in a finite time.
The functional $F_{t \rightarrow g}$ ensure that all the fixed points are strongly connected if $t \subseteq S$ is strongly connected.

Let $\mathcal{F}_g(t) = \mu F_{t \rightarrow g}$ the least fixed point of $F_{t \rightarrow g}$.
This fixed point can be computed in practice thanks to the theorem \ref{th:tarski}.
$\mathcal{F}_g(t)$ correspond to the smallest strongly connected cycle containing the subset $t$ that can reach the subset $g$.
Thanks to the definition of the functional $F_{t \rightarrow g}$, $\mathcal{F}_g(t) \cap g = \emptyset$ and $Post(\mathcal{F}_g(t)) \subseteq t \cup g$.
More over, let $t,g \subseteq S$ so that $Post(t) \cap g \neq \emptyset$, then any trajectory $s_0,s_1,s_2,...$ of $\Asol'$ starting in $\mathcal{F}_g(t)$ ($s_0 \in \mathcal{F}_g(t)$) stay in $\mathcal{F}_g(t)$, until it reach $g$, in other words $\forall i\in \mathbb{N}, (s_i \in \mathcal{F}_g(t)) \lor (\exists j<i, s_j \in g)$.
This decomposition allow us to consider modules of the nondeterministic graph that have deterministic transitions.

Lets now define the decomposition of the plan in strongly connected components.
For $g \subseteq S$, let $\mathfrak{F}_g = \{ \mathcal{F}_g(\{n\}) \mid n \in \inpre(g) \}$.
$\mathfrak{F}_g$ correspond to the set of all the smallest strongly connected components that deterministically go to the subset $g$.
The uniqueness of  $F_{t \rightarrow g}$ least fixed point ensure the uniqueness of $\mathfrak{F}_g$.

For a set of set $X \subset 2^{2^S}$, let $\tilde{X} = \bigcup_{x \in X} x$.
Let the sequence $\{\mathcal{K}_i\}_{i \in \mathbb{N}}$ define by:
\begin{equation*}
\begin{split}
\mathcal{K}_{i+1} &= \mathfrak{F}_{\tilde{\mathcal{K}}_i} \cup \mathcal{K}_i\\
\mathcal{K}_0 &= G
\end{split}
\end{equation*}
for $i \in \mathbb{N}$. 

By observing that,
\begin{equation}
\begin{array}{llll}
H : &2^{2^S} &\rightarrow &2^{2^S}\\
&X & & \mathfrak{F}_{\tilde{X}} \cup X \cup \{ g \}
\end{array}
\end{equation}
is a monotonic functional on a finite set $2^{2^S}$ and by using theorem \ref{th:tarski}, we know that the least fixed point of $H$ exist and is computable in finite time.
As $\mathcal{K}_i = H^i(\emptyset)$, we can deduce that the sequence $\{\mathcal{K}_i\}_{i \in \mathbb{N}}$ is converging to an element $\mathcal{K}^\star \in 2^{2^S}$ in a finite number of steps.

$\mathcal{K}^\star$ corresponds to the decomposition of the plan in strongly connected cycles.
We need now to be sure that the decomposition of the plan is complete, ie all the nodes of the plan must belong to the decomposition:
\begin{prop}
For a valid plan, $\tilde{\mathcal{K}}^\star = S$.
\end{prop}
\begin{proof}

By definition of $\mathcal{F}_g$, we have:
\begin{equation}
n \in S \setminus g \Leftrightarrow \mathcal{F}_g(\{n\}) \neq \emptyset
\end{equation}
This imply that:
\begin{equation} \label{eqn:equiv_f_empty}
\mathfrak{F}_g = \emptyset \Leftrightarrow Pre(g) = \emptyset
\end{equation}

Moreover, by definition of $\mathfrak{F}_g$:
\begin{equation} \label{eqn:f_empty}
\tilde{\mathfrak{F}}_g \cap g = \emptyset
\end{equation}
For $\mathcal{K}^\star$, as $\mathcal{K}^\star = \mathfrak{F}_{\tilde{\mathcal{K}}^\star} \cup \mathcal{K}^\star$ and thanks to equality \ref{eqn:f_empty}, we have $\mathfrak{F}_{\tilde{\mathcal{K}}^\star} = \emptyset$.  
By using equivalence \ref{eqn:equiv_f_empty}, we prove that $Pre(\tilde{\mathcal{K}}^\star) = \emptyset$.

By using the definition of $\mathcal{F}_g$,
we can show that for all $F \in \mathcal{K}^\star \setminus \{G\}$, $\outpost(F) \subset \tilde{\mathcal{K}}^\star$.
This imply that $\outpost(\tilde{\mathcal{K}}^\star) = \outpost(G)$.
As the problem is a terminating problem, $\outpost(G) = \emptyset$, this imply that 
$\outpost(\tilde{\mathcal{K}}^\star)  = \emptyset$.

As $\inpre(\tilde{\mathcal{K}}^\star)  = \emptyset$ and $\outpost(\tilde{\mathcal{K}}^\star)  = \emptyset$, all the nodes outside $\tilde{\mathcal{K}}^\star$ are not connected to $G$.
Then the validity of the plan prove that all the nodes outside   $\tilde{\mathcal{K}}^\star$ cannot belong to the plan.
\end{proof}


\begin{figure}
	\center
	\includestandalone[width=0.7\textwidth]{plan_decomposition}
	\caption{Decomposition of the plan in strong cycles components (red boxes) and transitions between them (blue arrows). The agent goes from area \textit{init} to stay in the set \textit{G} (in the green box) following the controls actions (in black arrows).}
	\label{fig:environment}
\end{figure}

\subsubsection{Fairness property}
In the previous section we have settled the decomposition of the graph in strong cyclic components.
We will now investigate when these strong cyclic components need to verify fairness property.

If the plan $P$ is a solution of the nondeterministic planning problem, then every run reach the set $G$ in a finite time.
Lets $\mathcal{K}^\star$ be the previously defined decomposition of the plan $P$.
In the following paragraph, we will establish when the fairness property must be verified for each element of $\mathcal{K}^\star$.

Let define the following subsets of $\mathcal{K}^\star$:
\begin{align}
\mathcal{K}_{unfair} &= \{ F \in \mathcal{K} \mid F \subseteq G \}\\
\mathcal{K}_{fair} &= \mathcal{K}^\star \setminus \mathcal{K}_{unfair}
\end{align}

\begin{prop}
All the elements of $\mathcal{K}^\star \setminus {G}$ verify fairness property.
\end{prop}

\begin{proof}
Let $\Pi$ a finite-state controller that is a solution of the problem $P$ and $\mathcal{F} \in \mathcal{K}^\star \setminus \{G\}$ a $\Pi$-reachable set of nodes.
If $\mathcal{F}$ does not verify the fairness property we can choose a $\Pi$-run $\pi = \{s_i\}_{i\in\mathbb{N}}$ so that it exists $k\in\mathbb{N}$ where $\forall k'>k, s_{k'} \in \mathcal{F}$, this means that $Inf(\pi) \subset \mathcal{F}$

As $G \cap \mathcal{F} = \emptyset$, we have $Inf(\pi) \cap G =\emptyset$, so this run is not accepted, which contradict the fact that $\Pi$ is a solution of $P$.
\end{proof}


\subsubsection{Fairness property of product systems}
In our case the systems that that we will use are products of FTS and BA. We will have the information about the fairness property for each of the system, so we need to investigate the link between the fairness property of the product system and all the systems.

\begin{prop}
Let $S = S_1 \otimes \dots \otimes S_n$ the product automaton of $n$ finite transition systems (FTS or BA) $(S_1,\dots,S_n)$.
Let $\mathcal{F}$ a strong cyclic component of $S$ obtained with the strong cyclic decomposition.
If $\mathcal{F}$ is unfair then $\mathcal{F}|_{S_i}$ is unfair for $i = 1,\dots,n$.
\end{prop}

\begin{proof}
If the subsystem $S_j$ is fair for $j \in \llbracket 1,n \rrbracket$ on $\mathcal{F}|_{S_j}$, then all the paths exit $\mathcal{F}|_{S_j}$ in a finite time, this imply that all the runs on the product automaton $S$ exits $\mathcal{F}$ in finite time as well.
\end{proof}

Ones should note that this property is valid for products of systems such as finite transition system or \buchi{} automaton (or any combination of them).

For a \buchi{} automaton, all the cycles are unfair.
For a FTS, we will specify the fairness property with a function that return the maximal time that the system can spend in a subset of nodes
(for an unfair strong cycle of the FTS, this time will be equal to $+\infty$).

We can formally define the escape function for the product automaton:
\begin{property}
The escape function of the product automaton $S$ is:
$$T_{escape}^S = \min{T_{escape}^{S_i}}$$
where $T_{escape}^{S_i}$ is the escape function of the system $S_i$.
\end{property}

\begin{proof}
\textit{I need to provide something more rigorous.}
If the faster system $S_i$ escape the set of nodes $\mathcal{F}|_{S_i}$ in $T^{S_i}_{escape}(\mathcal{F})$, then the product system escape the set of nodes $\mathcal{F}$ in $T^{S_i}_{escape}(\mathcal{F})$.
\end{proof}

\section{Backward reachability algorithm}
In the previous section we have seen that every plan can be decomposed in a strongly connected cyclic components.
We also have established when modules of a valid plan needs to verify fairness property.
In this section we will present the algorithm that use the previous observations in order to find a plan.

The main idea of our algorithm is to visit the strong cyclic components from the smallest (in term of number of nodes) to the biggest using a Breadth First Search (BFS). The rest of the plan is done with a Depth First Search (DFS) algorithm .
Our goal is to find the decomposition of the plan so that the decomposition verify the previous property (fairness and reachability to the goal set).

As we have seen in the previous section, all the plan can be decomposed in this structure, this means that this algorithm is complete.

We will associate the escaping function to the planning domain:
\begin{equation}
T_{escape} : G,U \rightarrow \mathbb{R}^\star \cup \{+\infty\}
\end{equation}

Lets use the following notation $F_p \hookrightarrow Plan$ for the truth value of the following assertion:
$$\forall n \in \mathcal{F}_p \mid \forall v \in Post_{u_n}(n), \exists w \in Post_{u_n}(n) \cap Plan, H(v)=H(w)$$

The function $Expand(Plan)$ is performing the BFS to find sets of nodes in $Q \setminus Plan$ and controls that verify $Post(F_p) \rightarrow Plan$.

\comment{Here I must describe a bit more the construction of the plan:
How do I add the $F_p$ sets, what transitions do I keep, which on do I get ride of...
\begin{itemize}
\item Escape function
\item define the escape function
\item 
\end{itemize}}



\begin{algorithm}
\SetAlgoNoLine
\KwData{$\mathcal{A}_p, T_{escape},cost$}
\KwResult{$\mathcal{P}$} 

 $Q = \{ Expand(\mathcal{F}) \}$\;

 $Q^\star$: set of valid plan for the system\; 
 \While{$Q\neq\emptyset$}{
 	$Q = Sort_{cost}(Q)$\;
 	$Plan,F_p = Pop(Q)$\;
 	
  \uIf{
  $T_{escape}(F_p) < \infty$
  or
  $F_p \hookrightarrow Plan$}{
  
    Add $F_p$ to $Plan$\;
	Update visited set\;
	
	\uIf{$init \subseteq Plan$ and $\mathcal{F} \subseteq Reach_{Plan}(init)$}{
       Add path to $Q^\star$\;
     }
     \uElse
     {
       Generate the set of predecessors of $Plan$\;
       Add $Expand(Plan)$ to $Q$\;
     }
   }
 }
 
 $\mathcal{P} = \argmin_{cost}{Q^\star}$\;
 
 \caption{Backward reachability algorithm}
\end{algorithm}

Talk about the complexity of the algorithm.

I need to do a tikz picture to show how the algorithm is working.

\section{Discussion}
\comment{Not so sure about it:}
From our observations, it is possible to determine what is the biggest fixed point size for a specific systems.
In the case of the single integrator model the maximum fixed point is equal to the maximum number of cells of the abstraction that can cover the set of successors for a chosen control.
This constraint reduce the size of possible solutions.
However this parameter is not easy to determine, it depends on the formula and on abstraction.
We will see in the \textit{results section} that most of the cases that we have been evaluating, the size of the fixed point can be quite small for a single system. however, there size blow up in case of multi agent control.

Until then, we have used a system that is fully observable, this imply that the \buchi{} automaton used is deterministic.
This restrict the set of LTL formula usable. 

The previously defined algorithm can be extended to be used with nondeterministic BA, this increase the complexity of the algorithm. 
Instead of finding the fixed points for a set of controls, we can also choose a the set of observations.

\comment{Talk about the fixed points and the complexity}

\section{Conclusion}
In this chapter we have been presenting an algorithm that is using strong fairness property in order to find a plan for the quadricopter.



In graph search algorithm, deterministic models are actually preferable to non deterministic one. One goal of the translation algorithm to NBA is to reduce the non determinism as much as possible. 
To reduce the non determinism, it is possible to consider one fragment of LTL formulas that only produce DBA instead of NBA.
However, this reduce the expressiveness. Another way is to use other class of automata (ex: Rabin Automaton) that tend to produce more deterministic results.
In our algorithm, the complexity of the algorithm increasing as the non determinism increase, we have been using the \buchi{} Automaton anyway.