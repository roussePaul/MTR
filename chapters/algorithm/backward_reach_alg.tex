\section*{Notation}
\begin{tabular}{ll}
FTS:& Finite Transition System\\
LTL:& Linear Temporal Logic\\
BA: & B\"uchi Automaton\\
DBA:& Deterministic B\"uchi Automaton\\
NBA:& Nondeterministic B\"uchi Automaton\\
BFS:& Breadth First Search\\
DFS:& Depth First Search\\
\end{tabular}

For $X,Y$ two sets, $X|_Y = \{x \in X \mid x \notin  Y \}$, $2^X$ is the power set of $X$.

Let a graph $G = (V,E)$.
For a node $x \in V$, $Post(x)$ and $Pre(x)$ correspond respectively to the set of successors and predecessors of $x$. 
For a set of nodes, we define $X \subseteq V$, $Post(X) = \bigcup_{x \in X} Post(x)$, $\outpost(X) = Post(X) \setminus X$, $Pre(X) = \bigcup_{x \in X} Pre(x)$ and $\inpre(X) = Pre(X) \setminus X$.

For $X_1,\dots,X_n$ n sets and $Y \subset X_1 \times \dots \times X_n$, lets define the projection of $Y$ on $X_i$ with $Y|_{X_i} = \{x_i \mid (x_1,\dots,x_n) \in Y\}$.
The powerset of $X$ will be denoted $2^X$.
$\leftint a,b \rightint$ denote the segment of $\mathbb{N}$ between $a$ and $b$.

For a finite set $X$, and $Y \subseteq 2^X$, we define $\tilde{Y} = \bigcup_{y\in Y} y \subseteq X$.

\section{Introduction}
\newcommand{\Aphi}{\mathcal{A}_\varphi}%
\newcommand{\Fts}{\mathcal{F}}%
When the discretization of the state space and of the input space is finite the previously computed abstraction result in a Finite Transition System (FTS) $\Fts$. This FTS is meant to be used with the Linear Temporal Logic (LTL) specifications in order to synthesize a controller. This chapter details the controller synthesis algorithm.

As the final FTS is usually non deterministic, we have been using a slightly modified backward reachability algorithm that is using the maximal time of travel of the agent in order to prove the actual LTL fairness.

LTL formula can associate to an infinite sequence of observations a truth or a false value. These formulas have first been introduced in computer science fields for verifications purposes and yet attract interest of the control community to express high level specifications easily.
The power of such a language rely in its expressiveness and the ability to translate these formulas into a formal mathematical object that is easily manipulable: the \buchi{} Automaton.

LTL formulas can be translated in a \buchi{} Automaton that have a finite number of transition bringing graph theory into the field of verification.
Any sequence of observation that is part of the language of an LTL formula $\varphi$ will verify a so called acceptance condition of the corresponding \buchi{} Automaton $\Aphi$.
Adding the previously found abstraction, the system and its specifications are now expressible within the same class of object: finite state machines.
One can compose them into a \textit{Product Automaton} that encapsulate both the behaviour of the system and the formula specifications into a single automaton.
Every path verifying the acceptance condition in the Product Automaton respect both transitions in $\Fts$ (ie the dynamic of the system) and the acceptance condition $\Aphi$ (ie the formula $\varphi$).

The finiteness of the Product Automaton allow us to us graph search algorithm to generate controllers that force the system to verify the LTL formula.

In our case, the $\Fts$ is not deterministic and might have self-loops, this brought some more challenges in order to generate the controller out of it.
In this chapter, we will first introduce the necessary definitions, then detail the product of $\Fts$ and $\Aphi$, and finish with the description of the a slightly modified backward reachability algorithm that can work with deterministic FTS.

\subsection{Related work}
In linear temporal logic, the accepting set must be reached in finite time (fairness property). For a deterministic finite transition systems, the solutions already verify this property: a solution is done in a finite sequence of state/transition, so in finite time as well.
For non deterministic planning problems, this property is not granted. A solution plan with a cycle outside of the goal set will have trajectories that loops infinitely.

% Strong cyclic planning
Assuming that all transitions of a cycle will be taken in an infinite run (fairness property) can partially solve the issue.
Strong cyclic algorithms find plans with cycles, the global fairness property ensure that the solution will reach the goal set in finite time.
However, if this hypothesis can be justified in action planning and in verification in computer science, this assumption cannot be done in controller synthesis.
A wrong control combination can lead to limit cycles or equilibrium that might not be escaped.

The solution the that we brought is a strong cyclic algorithm with local fairness property. This means the assumption of fairness is not a global assumption any more and needs to be computed according to the cells shape of the state space discretization and to the control combinations
This part is presenting the planning under strong fairness constraint.

I will first present a graph decomposition. This decomposition will be used to show that any plans of a non deterministic with local fairness property problem can be decomposed in a graph of strongly connected cyclic modules. If each of the modules are fair, all the runs will reached the goal set in finite time.
This decomposition will be then used to create an algorithm that search for these solutions.

%Lets consider a product automaton $\Pi_\varphi$ between a finite transition system $\mathcal{F}$ and a nondeterministic b\"uchi automaton $\mathcal{A}_\varphi$ obtained from a LTL property $\varphi$. Lets call $\widetilde{\Pi}_\varphi$ the finite transition system that have the same nodes, initial states and transitions than $\Pi_\varphi$.
%
%In the case that $\Pi_\varphi$ have cycles that does not contain any accepting nodes, it can happen that a run is in $\widetilde{\Pi}_\varphi$ but not in $\Pi_\varphi$.
%This happen when the cycle "block" the system (the state will never escape the cycle). In order to suppress this behaviour, we have to detect which control sequence can block the system.

\comment{
\cite{de2010generalized}
\cite{patrizi2013fair}
By modelling the system in this way we are losing a lot of expressiveness power of the LTL. However, the complexity remain more or less the same than before 2EXPTIME-complete ($\mathcal{O}(2^{2^{n^k}})$) (\textit{not so sure about it, double check information}).
}

Non determinism model with LTL planning has been investigated mostly in the sensing non determinism or environment uncertainty.
Many solutions in $\mu$-calculus formulation (generalized reactivity) has been investigated. However they perform well in an environment with low non determinism (the complexity of the problem does not make it suitable for a motion planning problem).
ho alt
As temporal logic is mostly used for high level control specifications, usually only the low level controller has to deal with the noise.
That is why most of the motion planning problems with LTL specifications  assume that the motion of the robot is deterministic.
Another reason lie in the state space explosion problem: relatively simple planning problems can result in an unrealistic needs of computing resources.

Some attempts using Markov decision process bring good results at reducing the complexity and using LTL specifications on real robots. These models can then provide a success probability of the LTL formula. 

In the motion planning community, the Fully Observed Non Deterministic problem  

In a planning problem, a solution plan cannot have cycles that does not contain any goal nodes, otherwise the agent might loop infinitely on the same cycle without meeting the goal set. If the system is verify fairness property, then any plan even with cycles will solve the problem. Otherwise the planner have to avoid any cycles.
In its simplest form, non deterministic cycles appear in system that contain self-loops. If the non determinism for the rest of the system is acquired, then by using a fragment of LTL formulas (without the next operator), a regular deterministic planning algorithm can solve the problem.

\comment{For motion planning, the fairness property is verified for a set of nodes if the agent leave the set of nodes in a finite time.
In our case, the fairness property is not always met: a "wrong" combination of controls can create an equilibrium point or a limit cycle.
Therefore checking the truth value of this property cannot be done globally but for each cycles of the plan that does not contain the goal set.
As the number of cycles and control combination is high, checking the fairness property is not possible in practice. This will be done online.}


\comment{Talk about why they have been doing this? Deal with uncertainty about the environment.
Why did you chose LTL?
Why did you chose B\"uchi Automaton?
Talk about other solutions that might have been smarter.}


%\cite{de2010generalized}
%\cite{patrizi2013fair}
%Fully Observable Non-Deterministic Planning:  FOND
%
%The guaranties that an nondeterministic planner must fulfil are:
%\begin{itemize}[noitemsep,nolistsep]
%\item \textbf{Completness.}
%\item \textbf{Soundness.} Every given solutions are correct
%\item \textbf{Correctness.} 
%\item \textbf{Fairness.}
%\end{itemize}
%
%\subsection{Related work}
%How to deal with nondeterminism?
%Different approaches:
%\begin{itemize}
%\item general game formulation: GR(1) (however, the formulation does not fit to our needs): in \cite{de2010generalized} and \cite{Kissmann2009}, the strong fairness property is expressed thanks in a LTL formulation, however it presuppose a knowledge about cyclic actions fairness property, this is adapted to action planning where we know that if the action is infinitely repeated, then the action will success infinitely often. This does not really fit any motion planning non determinism where the fairness property depend on a control configuration over the cells. Using this kind of framework will force us to go through all the possible action combinations and determine which one is fair.
%\item Fixed point ($\mu$-calculus that is related to the GR formulation as well).
%\item \cite{fu2011simple} is solving the FOND problem in the case of strong fairness assumption. This assumption is global, this is not the case for us as some of some control configurations might be unfair. The fairness property is local in our case.
%\end{itemize}
%
%What I did is an adaptation of the \cite{fu2011simple} with a backward reachability algorithm.

\section{Preliminaries}
\subsection{Linear Temporal Logic}
\newcommand{\AP}{\mathrm{AP}}
LTL is a specification language first introduced in \cite{pnueli1977temporal}. Since then it has been widely used in robot motion and action planning mainly for its expressiveness and mathematical equivalent representation in \buchi{} Automaton.
LTL property are defined inductively with :
\begin{equation}
\varphi ::= 
\true \mid 
a \mid 
\varphi_1 \land \varphi_1 \mid
\lnot \varphi \mid
\LTLnext \varphi \mid
\varphi_1 \LTLuntil \varphi_2
\end{equation}
where $\true$ is the symbol defined by $\true = a\lor \lnot a$, $a \in \AP$ is a predicate (that will depend on the state on the robot), $\AP$ a set of predicates, $\varphi_1$ and $\varphi_2$ are LTL formulas, $\lnot$ is the not operator defined by $a = \lnot \lnot a$, $\LTLnext$ is the next operator and $\LTLuntil$ is the until operator.
The truth of an LTL formula is defined in this way:
\begin{nameddef}{LTL property}
The sequence of observation $\sigma = S_0 S_1 S_2 ...$, with $S_k \in 2^{\AP}$ a set of observed labels for $k=0,1,2,...$, satisfy the LTL formula $\varphi$ iff $(\sigma,0) \vDash \varphi$ where $\vDash$ is defined recursively by: 

\begin{tabular}[b]{rcl}
$(\sigma,k) \vDash a$ & $\leftrightarrow$ & $a \in S_k$\\
$(\sigma,k) \vDash \lnot \varphi$ & $\leftrightarrow$ &  $(\sigma,k) \nvDash  \varphi$ \\
$(\sigma,k) \vDash \LTLnext \varphi$ & $\leftrightarrow$ &  $(\sigma,k+1) \vDash  \varphi$ \\
$(\sigma,k) \vDash \varphi_1 \lor \varphi_2$ & $\leftrightarrow$ &  $(\sigma,k) \vDash  \varphi_1$ or $(\sigma,k) \vDash  \varphi_2$ \\
$(\sigma,k) \vDash \varphi_1 \LTLuntil \varphi_2$ & $\leftrightarrow$ &  $\exists k' \in \left [k, +\infty \right ] , (\sigma,k') \vDash \varphi_2$ and \\
& & $\forall k'' \in (k,k'), (\sigma,k'') \vDash \varphi_1$ \\
\end{tabular}
\end{nameddef}

We also define some useful operators: \textit{eventually} $\LTLeventually \varphi = \true \LTLuntil \varphi$, \textit{always} $\LTLalways \varphi = \lnot \LTLeventually \lnot \varphi$, \textit{implication} $\varphi_1 \LTLimply \varphi_2 = \lnot \varphi_1 \lor \varphi_2$.
More details can be found in chapter 5 of \cite{principlemodelchecking}.

All the power of such a language lie in the ability to transform a human writeable formula in a machine manipulable data. LTL formula can be translated to an automaton structure that can be easily manipulated with discrete models. The problem of path planning is then reduced to finding a path in graph.

\subsection{Automaton}
Every LTL formula can be translated in a Nondeterministic \buchi{} Automaton:
\begin{nameddef}{Nondeterministic B\"{u}chi Automaton}
$\mathcal{A}_{\varphi} = (Q, Q_0, 2^{AP}, \delta, \mathcal{Q})$
where:
\begin{itemize}[noitemsep,nolistsep,topsep=0pt,after=\relax]
\item $Q$ finite set of states;
\item $Q_0 \subseteq Q$ a set of initial states;
\item $2^{AP}$ the alphabet;
\item $\delta: Q \times 2^{AP} \times Q$ a transition relation ;
\item $\mathcal{Q}$ set of accepting states.\popQED
\end{itemize}
\end{nameddef}
It should be noted that a trace with elements in $2^{AP}$ verify the LTL formula if there is corresponding sequence of states of the NBA that infinitely goes to the accepted set $\mathcal{Q}$.

Nota: if $\forall q \in Q, \forall a \in 2^{AP}, | \delta(a,q) | \leq 1$, then $\mathcal{A}_{\varphi} = (Q, Q_0, 2^{AP}, \delta, \mathcal{Q})$ is a \textit{Deterministic B\"uchi Automaton} (DBA).

The FTS will be defined as a system (see defintion \label{def:system}) with a finite set of transition (in practice this imply that the set of states is finite as well). Also the same notation as in defintion \label{def:system} will be used.

When it comes to multi-agent control, 2 methods can give us the FTS, either the dynamical models are concatenated and then the FTS is computed using abstraction methods. Either the 2 FTS are computed separately and the final FTS is then obtained by computing the product of the 2 FTS:
\begin{nameddef}{Product of 2 FTS}
The product automaton $\mathcal{F}_p$ of 2 non deterministic FTS $\mathcal{F}_1$ and $\mathcal{F}_2$ is defined by
$\mathcal{F}_p = \mathcal{F}_1 \otimes \mathcal{F}_2
= (X',X_0',U',\delta',Y',H')$
where
$X' = X_1 \times X_2$ is the set of states,
$X_0' = X_{10} \times X_{20}$ is the set of initial states,
$U' = U_1 \times U_2$ the input set,
$Y' = Y_1 \times Y_2$ the output set,
$H': X_1,X_2 \rightarrow (H_1(X_1),H_2(X_2))$ the output map,
$\delta' \subseteq X' \times U \times X'$
is the transition relation defined by
$\left \langle x_1,x_2 \right \rangle \in \delta'(\left \langle x_1',x_2' \right \rangle,\langle u_1,u_2 \rangle)$ iff $x_1 \systransition{\mathcal{F}_1}{u_1} x_1'$ and $x_2 \systransition{\mathcal{F}_2}{u_2} x_2'$.
\end{nameddef}
This is a synchronous product as every transition of the product correspond to a transition in each of the models.

\newcommand{\Aprod}{\mathcal{A}_p}
We would like to force the system to verify an LTL formula. We will assume that the observation function of the FTS is in the following form: $H:X \rightarrow 2^{AP}$ and $Y = 2^{AP}$.
The product automaton for an nondeterministic FTS is defined as follow:
\begin{nameddef}{Product of a NBA and a FTS}
The product automaton $\Aprod$ of the NBA $\Aphi$ and the non deterministic FTS $\mathcal{F}_c$ is defined by
$\Aprod = \mathcal{F}_c \otimes \Aphi
= (Q',Q_0',\delta',\mathcal{Q}')$
where
$Q' = X \times Q$ is the set of states,
$Q_0' = X_0 \times Q_0$ is the set of initial states,
$\mathcal{Q}' = X \times \mathcal{Q}$ the acceptance set,
$\delta' \subseteq Q' \times U \times Q'$
is the transition relation defined by
$\left \langle x',q' \right \rangle \in \delta'(\left \langle x,q \right \rangle ,u)$
iff $x' \in Post_u(x)$, $q' \in \delta(q,H(x'))$ and 
$\forall y \in Post_u(x), \delta(q,H(y)) \neq \emptyset$.
\end{nameddef}
Roughly speaking, a $u$-transition in the product automaton is valid iff for every possible next observation of a $u$-transition in the FTS, it exists a valid transition in the B\"uchi Automaton.

Every path in the product automaton that infinitely goes to the acceptance set verifies the LTL formula $\varphi$ and takes only valid transitions of the FTS (so it respect the model of the system).
So now, if we find a plan that force the product automaton to go infinitely often to the accepted set, then the controlled system will verify the LTL formula.
It is important to note that the acceptance set must be reached in a finite time otherwise the LTL formula is not verified.

\subsection{Fix point algorithm}
%% introduce the fixed point property, make a link between mu calculus
%% I just need a property that establish the working conditions for the fixed point property and the finitness of the algorithm.

% definition of a fixed point
% definition of the least fixed point
% definition of a monotonic fonction t: 2^S -> 2^S
% theorem tarski-knaster for the fixed point of a monotonic function -> existence of the least fixed point
% include the finitness directely inside the theorem, or as a note
In the next parts, we will use operations over sets of nodes in the graph. In order to find subset of nodes where properties are verified, we will use fixed point computation.

Let the graph $(S,E)$, a functional $\tau$ is a function over powersets of $S$: $\tau: 2^S \rightarrow 2^S$. We say that $b$ is a \inlinedef{fixed point} of the functional $\tau$ if $\tau(b) = b$.
The functional $\tau: 2^S \rightarrow 2^S$ is  \inlinedef{monotonic} iff $\forall a,b \in 2^S, a \subseteq b, \tau(a) \subseteq \tau(b)$.
In \cite{tarski}, it is shown that for a monotonic functional $\tau$, the set of fixed points has a least and greatest element denoted by $\mu \tau$ and $\nu \tau$ respectively:
\begin{namedtheo}{Tarski-Knaster}\label{th:tarski}
Let $\tau:2^S \rightarrow 2^S$ a monotonic functional:
\begin{itemize}[noitemsep,nolistsep]
\item $\mu \tau = \bigcap \{b \subseteq S \mid \tau(b) \subseteq b\} = \bigcup_{\alpha \in On} \tau^{\alpha}(\emptyset)$
\item $\nu \tau = \bigcup \{b \subseteq S \mid b \subseteq \tau(b) \} = \bigcap_{\alpha \in On} \tau^{\alpha}(S)$
\end{itemize}
where $\tau^{\alpha}$ is the $\alpha^{th}$ composition of $\tau$ and $On$ the class of ordinals.
\end{namedtheo}
In our case, $S$ will be a finite set and $On = \leftint 1,|S|\rightint$. 
Therefore the theorem ensure the existence and the finiteness of the least fixed point computation.
Please note that if $a$ and $b$ are least fixed points of the monotonic functional $\tau$, then $a \subseteq b$ and $b \subseteq a$, which means that $a=b$, which means that the least fixed point is unique.

\section{Decomposition in strongly connected cyclic components}
\newcommand{\planningdomain}{\ensuremath{ \tuple{\langle S, S_0, \mathcal{A}, \gamma \rangle} }}%
%
\newcommand{\controller}{\ensuremath{\systuple{ C, \{c_0\}, \Gamma, \Lambda, \systransition{\Fsc}{}, \Omega }}}%
%
\newcommand{\planningproblem}{\ensuremath{\tuple{ \langle \mathcal{D}, G \rangle}}}%
\newcommand{\Fsc}{\Pi}%
\newcommand{\Ftcs}{\Fts_\Fsc}%
\newcommand{\Asol}{\mathcal{A}_s'}%
\newcommand{\Aterm}{\mathcal{A}_s}%
%
Hereby we will introduce the definition of the controller and of the controlled system.
For every possible trajectories of the controlled system, the LTL formula $\varphi$ should be verified, this implies that the product of $\Aphi$ and the controlled system will verify reachability and fairness properties to the acceptance set.
Finally we will show that the controller must be solution of a terminating nondeterministic planning problem.

\begin{nameddef}{Finite-State Controller}
$\Fsc = \controller$ is a finite-state controller where
$C$ is the set of states,
$c_0$ is the initial state,
$\Gamma$ is the controller input alphabet,
$\Lambda$ is the output alphabet,
$\delta: C \times \Gamma \rightarrow C$ is the transition function and 
$\Omega: C \rightarrow \Lambda$ is the output function.
\end{nameddef}
In practice, for a product automaton $\Aprod = \systuple{Q',Q'_0,\delta',\mathcal{Q}'}$ and a FTS $\Fts = \systuple{X,X_0,\systransition{\Fts}{},U,Y,H}$, the controller $\Fsc = \controller$ will then be chosen with $C = Q' \cup \{c_0\}$, $\Lambda = U$ and $\Gamma = Y$.
A trajectory of the composed system will be:
\begin{figure}[H]
\centering
\begin{tikzpicture}
\tikzstyle{tr}=[-stealth]

\newcommand{\sysar}[2]{edge node[left,anchor=south west,yshift=-2pt,xshift=-2pt,pos=0]{\scalebox{0.7}{$#1$}}
node[anchor=south east,yshift=-3pt,xshift=-0pt,pos=1]{\scalebox{0.55}{$#2$}}}

\newcommand{\fakebox}[1]{...}
  \matrix (m) [matrix of math nodes,row sep=0em,column sep=1.3em,text height=2ex]
  {
  \Fts: & & x_0 & & x_1 & & x_2 & & \fakebox{x_1} \\
  \Fsc: &  c_0 & & c_1 & & c_2 & & c_3 & \fakebox{c_1}\\
  \Ftcs: & & (x_0,c_1) & & (x_1,c_2) & & (x_2,c_3) & &  \fakebox{c_1}\\
};
     
  \draw[tr] (m-1-3) \sysar{\Fts}{\Omega(c_1)} (m-1-5);
  \draw[tr] (m-1-5) \sysar{\Fts}{\Omega(c_2)} (m-1-7);
  \draw[tr] (m-1-7) \sysar{\Fts}{\Omega(c_3)} (m-1-7-|m-1-9.west);
  
  \draw[tr] (m-2-2) \sysar{\Fsc}{H(x_0)} (m-2-4);
  \draw[tr] (m-2-4) \sysar{\Fsc}{H(x_1)} (m-2-6);
  \draw[tr] (m-2-6) \sysar{\Fsc}{H(x_2)} (m-2-8);
  
  \draw[tr] (m-3-3) \sysar{\Ftcs}{H(x_1)} (m-3-5);
  \draw[tr] (m-3-5) \sysar{\Ftcs}{H(x_2)} (m-3-7);
  \draw[tr] (m-3-7) \sysar{\Ftcs}{H(x_3)} (m-3-7-| m-3-9.west);
\end{tikzpicture}
\end{figure}
This controller can be composed with the FTS $\Fts$: $\Ftcs = \Fts \circ \Fsc = \systuple{X_\Fsc,X_{\Fsc 0},\systransition{\Ftcs}{},Y,H_\Fsc}$ where:
\begin{itemize}[nolistsep,noitemsep]
\item $\X_\Fsc = X \times C$ the set of states,
\item $\X_{\Fsc 0} \subseteq X_0 \times C$ the set of initial states, defined by $(x_0,c) \in \X_{\Fsc 0} \Leftrightarrow c_0 \systransition{\Fsc}{H(x_0)} c$,
\item $\systransition{\Ftcs}{}$ the transition relation defined by:
\begin{equation}
(x,c) \systransition{\Ftcs}{} (x_+,c_+) \Leftrightarrow 
\left\{
\begin{split}
x &\systransition{\Fts}{\Omega(c)} x_+\\
c &\systransition{\Fsc}{H(x_+)} c_+
\end{split}
\right.
\end{equation}
\item $H_\Fsc$ the observation map: for $(x,c) \in X_\Fsc$, $H_\Fsc((x,c)) = H(x)$.
\end{itemize}
Contrary to the FTS, the controlled system does not have any inputs, however it is still possible to use operations on automaton previously defined by using a dumb input for all the transitions.
$\Fsc$ is said to be \textit{closed} if every reachable state of the controlled system $\Ftcs$ is associated with a control action.
Finally we can obtain the product of the composed system $\Ftcs$ and the BA $\Aphi$:
$\Asol = \Aphi \otimes \Ftcs = \systuple{S',S_0',\delta',G'}$.
$\Fsc$ is \textit{proper} if the acceptance set of $\Asol$ is reachable from every initial state and $\Fsc$ is said \textit{fair} if the acceptance set is reachable in finite time from every reachable states of $\Asol$.
We will say that $\Fsc$ is a valid controller if $\Fsc$ is \textit{closed}, \textit{proper} and \textit{fair}. If $\Fsc$ is a valid controller, we will say that the corresponding product automaton $\Asol$ is a solution of the problem.

Thanks to the special form of the controller, $\Asol$ correspond to the product automaton $\Aprod$ selecting just one control action for each of the reachable nodes.
Thanks to this property, we can work only with the product automaton in order to find a controller solution of the problem.

Due to the nature of the LTL formulas (that works on infinite sequences of observations), this problem is a non terminating planning problem.
It is shown in \cite{patrizi2013fair} that every non terminating nondeterministic planning problem can be solved like a nondeterministic terminating planning problem where the the initial set of the new planning problem correspond to the union of the initial set and the goal set.
Lets call $\Aterm = \systuple{S,S_0,\delta,G}$ the product solution of the nondeterministic terminating problem.
Where $S = S' \cup G_{post}$, with $G_{post}$ a set of nodes that have the same post transitions than the set $G'$ in $\Asol$, $G = G_{pre}$ a set of nodes that have the same predecessor transitions than $G'$ in $\Asol$, $S_0 = S_0' \cup G_{post}$ and $\delta$ defined by previous definitions of $G_{post}$ and $G_{pre}$ plus transitions of $\delta|_{(S' \setminus G')^2}$.

We showed that the controller synthesis with LTL formula can in fact be treated as a terminating nondeterministic planning problem. In the next sections, we will work with $\Aterm$ to solve the problem.

\subsubsection{Strong cycle decomposition}
A plan of a nondeterministic planning problem might have cycles outside of the goals set. Unfortunately, these cycles can keep the agent from reaching the goal set in finite time (a trajectory looping infinitely in a cycle will never reach the goal set).
By showing that the dynamical system cannot stay in each of the cycles indefinitely, it is possible to prove that despite the cycles, the fairness property hold.
This motivate the decomposition of the graph in cycles.
Hereby, we will use a constructive argument to show that every plan solution of a terminating nondeterministic planning problem can be decomposed in strongly connected cyclic components that deterministically go to the goal set. Later, this decomposition will be used to 
The strongly connected cyclic components correspond to subparts of the graph where every node is reachable from other nodes and that have cyclic trajectories.

Let $\Aterm = \systuple{S,S_0,\delta,G}$ a solution of the terminating nondeterministic problem.
The main idea of $\Aterm$'s decomposition is to encapsulate in modules all subgraphs that have cyclic trajectories. The modules will be found recursively starting from the goal set until all the graph is decomposed.
The description of the decomposition will be followed by a proof that for a valid plan all the nodes of the plan belong to the decomposition.

Strongly connected components will be found using fixed point algorithm.
Let $F_{t \rightarrow g}$ defined for $g,t \subseteq S$, $g \cup t = \emptyset$ by:
\begin{equation}
\begin{array}{llll}
F_{t \rightarrow g} :& 2^S & \rightarrow & 2^S\\
 & x &  & (Post(x) \cap S \setminus_g) \cup t
\end{array}
\end{equation}

For $x \subseteq y \subseteq S$ we have $F_{t \rightarrow g} (x) \subseteq F_{t \rightarrow g}(y)$, so $F_{t \rightarrow g}$ is a monotonic functional and theorem \ref{th:tarski} ensure that $F_{t \rightarrow g}$ have a unique least fixed point.
As the cardinality of $S$ is finite, we can compute the fixed point of $F_{t \rightarrow g}$ in a finite time.
The functional $F_{t \rightarrow g}$ ensure that all the fixed points are strongly connected if $t \subseteq S$ is strongly connected.

Let $\mathcal{F}_g(t) = \mu F_{t \rightarrow g}$ the least fixed point of $F_{t \rightarrow g}$ for $t,g \subseteq S$.
This fixed point can be computed in practice thanks to a direct application of the theorem \ref{th:tarski}.
$\mathcal{F}_g(t)$ correspond to the smallest strongly connected cycle containing $t$ that can reach the subset $g$.
Thanks to the definition of the functional $F_{t \rightarrow g}$, $\mathcal{F}_g(t) \cap g = \emptyset$ and $Post(\mathcal{F}_g(t)) \subseteq t \cup g$.
More over, let $t,g \subseteq S$ so that $Post(t) \cap g \neq \emptyset$, then any trajectory $s_0,s_1,s_2,...$ of $\Asol$ starting in $\mathcal{F}_g(t)$ ($s_0 \in \mathcal{F}_g(t)$) stays in $\mathcal{F}_g(t)$, until it reach $g$, in other words $\forall i\in \mathbb{N}, (s_i \in \mathcal{F}_g(t)) \lor (\exists j<i, s_j \in g)$.
This decomposition allow us to consider modules of the nondeterministic graph that have deterministic transitions to $g$.

Lets now define the decomposition of the plan in strongly connected components.
For $g \subseteq S$, let 
\begin{equation}
\mathfrak{F}_g = \{ \mathcal{F}_g(\{n\}) \mid n \in \inpre(g), \forall p \in \inpre(g) \setminus \{n\}, \mathcal{F}_g(\{p\}) \nsubseteq \mathcal{F}_g(\{n\}) \}
\end{equation}
$\mathfrak{F}_g$ correspond to the set of all the smallest strongly connected components that deterministically go to the subset $g$.
The uniqueness of  $F_{t \rightarrow g}$ least fixed point ensure the uniqueness of $\mathfrak{F}_g$.

For  of set $X \subset 2^S$, let $\tilde{X} = \bigcup_{x \in X} x \subseteq S$.
Let the sequence $\{\mathcal{K}_i\}_{i \in \mathbb{N}}$ define by:
\begin{equation*}
\begin{split}
\mathcal{K}_{i+1} &= \mathfrak{F}_{\tilde{\mathcal{K}}_i} \cup \mathcal{K}_i\\
\mathcal{K}_0 &= G
\end{split}
\end{equation*}
for $i \in \mathbb{N}$. 

By observing that,
\begin{equation}
\begin{array}{llll}
\mathcal{H} : &2^{2^S} &\rightarrow &2^{2^S}\\
&X & & \mathfrak{F}_{\tilde{X}} \cup X \cup \{ G \}
\end{array}
\end{equation}
is a monotonic functional on a finite set $2^{2^S}$ and by using theorem \ref{th:tarski}, we know that the least fixed point of $\mathcal{H}$ exists and is computable in finite time.
As $\mathcal{K}_i = H^i(\emptyset)$, we can deduce that the sequence $\{\mathcal{K}_i\}_{i \in \mathbb{N}}$ is converging to an element $\mathcal{K}^\star \in 2^{2^S}$ in a finite number of steps.

$\mathcal{K}^\star$ corresponds to the decomposition of the plan in strongly connected cycles.
Some properties need now to be verified. First, the completeness of the decomposition, second, we need to be sure that the final decomposition does not present any cycles in between the possible module transitions.
We need now to be sure that the decomposition of the plan is complete, ie all the nodes of the plan must belong to the decomposition:
\begin{prop}
For a valid plan, $\tilde{\mathcal{K}}^\star = S$.
\end{prop}
\begin{proof}
By definition of $\mathcal{F}_g$, we have:
\begin{equation}
n \in S \setminus g \Leftrightarrow \mathcal{F}_g(\{n\}) \neq \emptyset
\end{equation}
This imply that:
\begin{equation} \label{eqn:equiv_f_empty}
\mathfrak{F}_g = \emptyset \Leftrightarrow Pre(g) = \emptyset
\end{equation}

Moreover, by definition of $\mathfrak{F}_g$:
\begin{equation} \label{eqn:f_empty}
\tilde{\mathfrak{F}}_g \cap g = \emptyset
\end{equation}
Let $\mathcal{K}^\star$ the set of set of $S$ previously introduced.
As $\mathcal{K}^\star = \mathfrak{F}_{\tilde{\mathcal{K}}^\star} \cup \mathcal{K}^\star$ and thanks to equality \ref{eqn:f_empty}, we have $\mathfrak{F}_{\tilde{\mathcal{K}}^\star} = \emptyset$.  
By using equivalence \ref{eqn:equiv_f_empty}, we prove that $Pre(\tilde{\mathcal{K}}^\star) = \emptyset$.

By using the definition of $\mathcal{F}_g$,
we can show that for all $F \in \mathcal{K}^\star$, $\outpost(F) \subset \tilde{\mathcal{K}}^\star$.
This imply that $\outpost(\tilde{\mathcal{K}}^\star) = \outpost(G)$.
As the problem is a terminating problem, $\outpost(G) = \emptyset$, this imply that 
$\outpost(\tilde{\mathcal{K}}^\star)  = \emptyset$.

As $\inpre(\tilde{\mathcal{K}}^\star)  = \emptyset$ and $\outpost(\tilde{\mathcal{K}}^\star)  = \emptyset$, all the nodes outside $\tilde{\mathcal{K}}^\star$ are not connected to $G$.
The plan is a valid solution of the problem, this means that all nodes outsides $\tilde{\mathcal{K}}^\star$ cannot belong to the plan as they do not reach the goal set.
\end{proof}

Lets define the directed graph of the decomposition: $\systuple{\mathcal{K}^*, \sigma}$, where $\mathcal{K}^*$ is the set of nodes and $\sigma \in (\mathcal{K}^*)^2$ the set of transitions defined by $u,v \in \mathcal{K}^*$, $(u,v) \in \sigma$ iff $Post(u) \cap v \neq \emptyset$. 

\begin{prop}\label{prop:nocycles}
The graph of the decomposition does not have any cycles.
\end{prop}

\begin{proof}
Thanks to the definition of the $\mathcal{F}_g$, we know that:
\begin{equation}
\forall k \in \mathcal{K}_{i+1}, \outpost(k) \subseteq \mathcal{K}_i
\end{equation}
More over, thanks to the definition of the problem, we have $\mathcal{K}_0 = G$ and $\outpost(G) = \emptyset$.
This implies that the graph of the decomposition does not have any cycles.
\end{proof}


The decomposition of a plan is shown \ref{fig:plan_decomposition}. If we manage to prove with the definition of the system that every module of the decomposition (ie every cyclic behaviour) leave the corresponding set of states in finite time, then it show that the goal set is reached in finite time.
\begin{figure}
	\center
	\includestandalone[width=0.7\textwidth]{plan_decomposition}
	\caption{Decomposition of the plan in strong cycles components (red boxes) and transitions between them (blue arrows). The agent goes from area \textit{init} to stay in the set \textit{G} (in the green box) following the controls actions (in black arrows).}
	\label{fig:plan_decomposition}
\end{figure}

\subsubsection{Fairness property}
In the previous section we have settled the decomposition of the graph in strong cyclic components.
We will now investigate when these strong cyclic components need to verify fairness property.

If the plan $\Aterm$ is a solution of the terminating nondeterministic planning problem, then every run reach the set $G$ in a finite time.
Lets $\mathcal{K}^\star$ be the previously defined decomposition of the plan $P$.
Thanks to property \ref{prop:nocycles}, we know that the graph of the decomposition does not have any cycles. More over, the goal set is reachable from every initial nodes.
Proving that every modules of $\mathcal{K}^*$ is fair, then it shows that the fairness property of the plan is verified (and therefore, all the trajectories will reach the goal set in a finite time).

The FTS $\Fts$ does not have any information on the fairness property of a subpart of the system. In order to get this, we need to use the definition of the dynamical and investigate if such infinite trajectories in a cycles might happen to the system.
The next chapter will discuss how such a property can be determined for dynamical systems.
From now, we will assume that the fairness property of a dynamical system $S$ is defined for a modules by a function:
\newcommand{\Tesc}{T_{escape}^S}%
\begin{equation}
\Tesc:X \times \U \rightarrow \R \cup \{+\infty\}
\end{equation}
$\Tesc$ is taking as an input the nodes of the module and the chosen control actions.


\subsubsection{Fairness property of product systems}
In our case the systems that that we will use are products of FTS and BA. We will have the information about the fairness property for each of the system, so we need to investigate the link between the fairness property of the product system and all the systems.

\begin{prop}
Let $S = S_1 \otimes \dots \otimes S_n$ the product automaton of $n$ finite transition systems (FTS or BA) $(S_1,\dots,S_n)$.
Let $\mathcal{F}$ a strong cyclic component of $S$ obtained with the strong cyclic decomposition.
If $\mathcal{F}$ is unfair then $\mathcal{F}|_{S_i}$ is unfair for $i = 1,\dots,n$.
\end{prop}

\begin{proof}
If the subsystem $S_j$ is fair for $j \in \llbracket 1,n \rrbracket$ on $\mathcal{F}|_{S_j}$, then all the paths exit $\mathcal{F}|_{S_j}$ in a finite time, this imply that all the runs on the product automaton $S$ exits $\mathcal{F}$ in finite time as well.
\end{proof}

Ones should note that this property is valid for products of systems such as finite transition system or \buchi{} automaton (or any combination of them).

For a \buchi{} automaton, all the cycles are unfair.
For a FTS, we will specify the fairness property with a function that return the maximal time that the system can spend in a subset of nodes
(for an unfair strong cycle of the FTS, this time will be equal to $+\infty$).

We can formally define the escape function for the product automaton:
\begin{property}
The escape function of the product automaton $S$ is:
$$T_{escape}^S = \min{T_{escape}^{S_i}}$$
where $T_{escape}^{S_i}$ is the escape function of the system $S_i$.
\end{property}
This property can be easily understood: for a module $\mathcal{F}$, if the faster system $S_i$ escape the set of nodes $\mathcal{F}|_{S_i}$ in $T^{S_i}_{escape}$, then the product system escape the set of nodes $\mathcal{F}$ in $T^{S_i}_{escape}$ at maximum.

\section{Backward reachability algorithm}
Every solution plan of the terminating nondeterministic problem can be decomposed in an acyclic graph of modules that verify a fairness property.
This observation will justify the following graph search algorithm.

The main idea of our algorithm is to visit the possible modules of the decomposition (strong cyclic components) from the smallest (in term of number of nodes) to the biggest using a Breadth First Search (BFS).
Then the graph of the decomposition is found using a Depth First Search (DFS) algorithm.
These choices are relevant in case of motion planning as the nondeterminism is mainly present locally (noise on the position of the robot for example). The challenge of finding the strongly connected components rely more in finding the right control combinations for a small set of nodes that bring to the goal set.
Whereas the graph of the decomposition require finding a potentially long path from the goal set to the initial, so the DFS is more suitable for this task.

Lets use the following notation $F_p \hookrightarrow Plan$ for the truth value of the following assertion:
$$\forall n \in \mathcal{F}_p \mid \forall v \in Post_{u_n}(n), \exists w \in Post_{u_n}(n) \cap Plan, H(v)=H(w)$$

The function $Expand(Plan)$ is performing the BFS to find sets of nodes in $Q \setminus Plan$ and controls that verify $Post(F_p) \rightarrow Plan$.

\comment{Here I must describe a bit more the construction of the plan:
How do I add the $F_p$ sets, what transitions do I keep, which on do I get ride of...
\begin{itemize}
\item Escape function
\item define the escape function
\item 
\end{itemize}}

\begin{algorithm}[H]
\SetAlgoNoLine
\KwData{$\mathcal{A}_p, T_{escape},cost$}
\KwResult{$\mathcal{P}$} 

 $Q = \{ Expand(\mathcal{F}) \}$\;

 $Q^\star$: set of valid plan for the system\; 
 \While{$Q\neq\emptyset$}{
 	$Q = Sort_{cost}(Q)$\;
 	$Plan,F_p = Pop(Q)$\;
 	
  \uIf{
  $T_{escape}(F_p) < \infty$
  or
  $F_p \hookrightarrow Plan$}{
  
    Add $F_p$ to $Plan$\;
	Update visited set\;
	
	\uIf{$init \subseteq Plan$ and $\mathcal{F} \subseteq Reach_{Plan}(init)$}{
       Add path to $Q^\star$\;
     }
     \uElse
     {
       Generate the set of predecessors of $Plan$\;
       Add $Expand(Plan)$ to $Q$\;
     }
   }
 }
 
 $\mathcal{P} = \argmin_{cost}{Q^\star}$\;
 
 \caption{Backward reachability algorithm}
\end{algorithm}

Talk about the complexity of the algorithm.

I need to do a tikz picture to show how the algorithm is working.

\section{Discussion}
\comment{Not so sure about it:}
From our observations, it is possible to determine what is the biggest fixed point size for a specific systems.
In the case of the single integrator model the maximum fixed point is equal to the maximum number of cells of the abstraction that can cover the set of successors for a chosen control.
This constraint reduce the size of possible solutions.
However this parameter is not easy to determine, it depends on the formula and on abstraction.
We will see in the \textit{results section} that most of the cases that we have been evaluating, the size of the fixed point can be quite small for a single system. however, there size blow up in case of multi agent control.

Until then, we have used a system that is fully observable, this imply that the \buchi{} automaton used is deterministic.
This restrict the set of LTL formula usable. 

The previously defined algorithm can be extended to be used with nondeterministic BA, this increase the complexity of the algorithm. 
Instead of finding the fixed points for a set of controls, we can also choose a the set of observations.

\comment{Talk about the fixed points and the complexity}

\section{Conclusion}
In this chapter we have been presenting an algorithm that is using strong fairness property in order to find a plan for the quadricopter.



In graph search algorithm, deterministic models are actually preferable to non deterministic one. One goal of the translation algorithm to NBA is to reduce the non determinism as much as possible. 
To reduce the non determinism, it is possible to consider one fragment of LTL formulas that only produce DBA instead of NBA.
However, this reduce the expressiveness. Another way is to use other class of automata (ex: Rabin Automaton) that tend to produce more deterministic results.
In our algorithm, the complexity of the algorithm increasing as the non determinism increase, we have been using the \buchi{} Automaton anyway.